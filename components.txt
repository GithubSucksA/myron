#functional components
#Plain JS function die props als argument kan accepteren en JSX react element returned
#Zonder hooks zijn het gewone functies die top down runnen en dan weg zijn
#Met hooks worden ze wel stateful
#Bij het doorgeven van props kunnen we kiezen om props mee te geven en daar van af te lezen props.x props.you
#We kunnen ook de props uitpakking (destructuring) dan plaatsen we de value die er op leven in {} (props) --> word ({waarde1, waarde2})

import React, states from “react”;

const Name = (props) => {
    useStates
    useEffects
    other handler functions or states

    return (alleen haakjes nodig bij meer dan 1 line return)
}

export default Name;


import React, { useState } from "react";

#function FunctionalComponent() {return <h1>aaa</h1>};  Zelfde idee maar andere syntax  
const FunctionalComponent = () => {    #Belangrijk om de functie met Hoofdletter te beginnen to mark it as React Function en binnen zo'n functies zijn helper functies zoals normale functie met een kleine beginnende letter
    const [count, setCount] = useState(0);
  
    const increase = () => {
        setCount(count + 1);
    }
  
    return (
        <div style={{ margin: '50px' }}>
            <h1>Welcome to Geeks for Geeks </h1>
            <h3>Counter App using Functional Component : </h3>
            <h2>{count}</h2>
            <button onClick={increase}>Add</button>
        </div>
    )
}
  
export default FunctionalComponent;


#class components
#Required dat we van een React.Component extenden en dat we een render functie gebruiken om JSX element te returnen
#De class component moet initiated worden en bevat dan meerdere lifecycles die actief zijn in verschillende phases van het component
#Deze lifycycle methods maken deze componenten ook van nature al stateful
#De constructor moet gebruikt worden omdat deze ook de state stored
#Class components krijgen van nature this.props mee om de doorgegeven probs van hun parents uit te lezen van wanneer ze worden geinitieerd in de parent component

import React, { Component } from "react"';
#Doordat hier Component word geimport zouden we hier onder bij het inheriten van de React.Component base class React weg kunnen laten
#Wanneer we hooks gebruiken(functional components) doen we ze normaal ook boven aan importen, maar hier geld hetzelfde dat deze op React. leven

class Name extends React.Component {
	render () {
		return (alleen haakjes nodig bij meer dan 1 line return);
	}
}



import React, { Component } from "react";
#“The constructor for a React component is called before it is mounted. When implementing the constructor for a React.Component subclass,
#you should call super(props) before any other statement. Otherwise, this.props will be undefined in the constructor, which can lead to bugs.”  
#In the constructor component gebruiken we this.state om de initial state te zetten daarna setState.
class ClassComponent extends React.Component {
    constructor(props) {      #initializer die altijd samen met super(props) gecalled moet worden
        super(props);
        this.state = {	 #state moet initieel geset worden in dictionary stijl
            count: 0
        };
        this.increase = this.increase.bind(this);   #VERPLICHT  Standaard binding van helper functies aan this wat moet gebeuren bij class components
    }
  
    increase() {     # ruimte voor helper functies
        this.setState({ count: this.state.count + 1 }); #Hoeven niet persé this.setState in een andere functie te stoppen
														#accepteert state en props als argumenten (props van parent && states van eigen component)
    }
  
    render() {    #render return
        return (
            <div style={{ margin: '50px' }}>
                <h1>Welcome to Geeks for Geeks </h1>
                <h3>Counter App using Class Component : </h3>
                <h2> {this.state.count}</h2> 
                <button onClick={this.increase}> Add</button>
  
            </div>
        )
    }
}
  
export default ClassComponent;


#DIFFERENCE BETWEEN FUNCTIONAL AND CLASS COMPONENTS
#In the above example, for functional components, we use hooks (useState) to manage the state. If you write a function component and realize you need to add some state to it,
#previously you had to convert it to a class component. Now you can use a Hook inside the existing function component to manage the state and no need to convert it into the Class component. 
#Instead of Classes, one can use Hooks in the Functional component as this is a much easier way of managing the state. Hooks can only be used in functional components, not in-class components.

#LIFECYCLE COMPONENTS https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
#Waar class components Lifecycles gebruiken, gebruiken functional Components hooks
#componentDidMount == useEffect() deze functies worden eenmaal gecalled na de eerste render van component (dus wanneer het mounted word to the DOM)
#Bij useEffect() geven we een functie mee als argument. De functie die na eerste render uitgevoerd moeten worden. 
	#Als 2de argument kunnen we een lege array [] meegeven om slechts één keer te runnen na eerste render van component
	#Als we in deze array bv de waarde van een state plaatsen triggered de useEffect functie na iedere state change render
#componentWillUnmount == useEffect hier gebruiken we useEffect ook voor, maar deze lifecycle method gebruiken we wanneer een component opgeruimd word om eerste nog dit te runnen
	#Gebruiken we vaak om clearInterval te callen
#componentDidUpdate(prevProps, prevState, snapshot) == useEffect()  deze functies worden iedere keer gecalled na een rerender van een component (meestal door state change)
	#W mogen direct setState callen (of this.setState) maar dit moet wel in een conditie zitten want anders hebben we een infinite loop
		#voor useEffect hebben we hier het 2de argument de [] voor die aangeeft op welke events we willen dat die vuurt.
		#under the hood heeft react de waarde van de vorige render zitten van bv de state in deze array en die word vergeleken met de huidige waarde om te zien of een rerender nodig is
		#de return function die dus voor componentWillUnmount staat kan ook gebruik maken van dit 2de argument.
#Als we met useEffect een functie returnen (dit geld voor functional components) dan weet React dat deze functie voor de componentWillUnmount staat
	#Deze functie word dus alleen gerunned als de component gaat unmounten voor clean-up van bv data-streams waarop connected is geworden of online status.	
#We kunnen meerdere useEffects gebruiken binnen een component. Dit kan handig zijn om ze apart te houden voor verschillende states of omdat we logica voor DidMount en WillUnmount apart willen houden van de DidUpdate(states vaak) die bij iedere rerender runned
	#useEffect word namelijk voor deze alle 3 gebruikt.

#De order van hoe we hooks callen is belangrijk. Ze worden top down uitgevoerd en daarna als een batch afgeleverd bij de render.
#Hooks moeten gecalled worden 'at the top state level'. Betekent dat ze niet in bv loop / if conditie / functie zijn verwerkt.
#Under the hood heeft react 'een shallow copy' van de orde van uitvoering van de vorige render waardoor de volgende sneller gaat.
	#Als dan doordat we een hook een level te diep gebruiken een hook niet uitgevoerd word door condities dan krijgen we bugs omdat react anders verwacht.
#Stel we gebruiken over meerdere files dezelfde type volgorde en logica van hooks dan kunnen we deze extracten naar een eigen file en in een functie stoppen (custom hook) en vaker gebruiker over componenten.
	#Deze custom hooks willen we als standaard naming convention beginnen met 'use' en de states en effects zijn geisoleerd voor de 2 componenten die bv deze zelfde hook gebruiken. 
#!! Redux is een react library die andere type state management meebrengt met een global store. Dit is handig voor huge apps.

#We kunnen een component resetten door een <Form key={version} /> tag te includen in ons component.
	#Zodra de waarde van de key veranderd word de hele component gereset naar zijn eerste vorm.
	
#useState kunnen we gebruiken op een directe manier useState("newValue") of we kunnen een functie meegeven. Als we een functie meegeven is het belangrijk dat we de previousState als argument meegeven.
	#De set functie die we meekrijgen bij initiating useState is pure en heeft dus geen return.
	#De set functie past de waarde pas aan na de volgende render (staging of processes in a snapshot) als we dus in dezelfde logica van dezelfde render de waarde uitlezen krijgen we niet de updated value. (flushSync voor manipulatie hiervan)

#useMemo kunnen we gebruiken wanneer we zwaardere calculaties runnen. We geven een pure function mee en een dependency list als argumenten.
--De calculatie word in cache gestored en vervolgens uitgelezen tegenover de waardes in de dependency als deze verschillen word pas opnieuw de zwaardere calculatie uitgevoerd en de cache ge-update.
#Stel we hebben wat componenten die zware JS erin hebben draaien, maar we hebben ook een colored them. Zodra we de colored them veranderen maar de andere waardes hetzelfde blijven is het handig useMemo te gebruiken.
	#In dat geval merken we dat de theme heel snel switched omdat de rest van het component zijn state uit de cache uitleest na verificatie dat die states ook ongewijzigd zijn.
#Als onze componenten langzaam zijn bij een re-render kunnen we beginnen na te denken over memoization.
#Als we een component re-renderen dan worden ook recursively zijn children re-rendered. Hiervoor kan ook useMemo handig zijn. Als dan de props ongewijzigd blijven vanuit de parent vind wederom alles vanuit cache plaats. (zelfs geen rerendering van child component)

function handleClick() {
  setName('Robin');
  console.log(name); // Still "Taylor"!   #We zien hier nog niet Robin omdat de waarde pas up-to-date word vanaf de volgende render.
}
function handleClick() {     #De code hieronder doet de age variable maar met 1 laten increasen, wederom de batching waarmee React werkt zorgt ervoor dat ze allemaal dezelfde initiele waarde + 1 geven.
  setAge(age + 1); // setAge(42 + 1)
  setAge(age + 1); // setAge(42 + 1)
  setAge(age + 1); // setAge(42 + 1)
}
function handleClick() {    #Op deze manier werkt het we, omdat we nu een updater functie meegeven waar we dus de prevState als argument meegeven. Manipuleer dus op deze manier waneer er extra compulatie is op dezelfde variabele. waarvan de waarde gevolgd dient te worden.
  setAge(a => a + 1); // setAge(42 => 43)
  setAge(a => a + 1); // setAge(43 => 44)
  setAge(a => a + 1); // setAge(44 => 45)
} 
const nextCount = count + 1;   #Hier een makkelijk voorbeeld van hoe we andere variabele kunnen gebruiken om hier ook verder mee te manipuleren en spelen. (Hier is count een state natuurlijk van useState)
setCount(nextCount);
console.log(count);     // 0
console.log(nextCount); // 1  

#State is read-only en niet mutable dus iedere keer vervangen we de waarde. Wanneer we een array of dictionary als state hebben word dit belangrijker want we kunnen niet de collection in state muteren,
--We dienen deze dus vaak geheel te kopieren en daarna de addition toe te voegen of eroverheen mappen etc.
#Stel we hebben dus een dictionary in onze state leven en we willen hier een waarde van updaten zodra een event getriggered word.
	#Dan dienen we in de setState function het volgende te doen om de andere waardes uit te pakken in de nieuwe state setState({...prev, key: e.target.value})
	#Alle keys die we niet specifiek adjusten maar wel al aanwezig waren worden door de ...prev syntax gekopieerd in het nieuwe object.
	#Dit kan iets triggier worden wanneer we met nested dictionaries werken, want dan pakken we vaker uit in nested levels, maar het globale idee blijft volledig hetzelfde.
const [person, setPerson] = useState({
	name: 'Niki de Saint Phalle',
	artwork: {
	  title: 'Blue Nana',
	  city: 'Hamburg',
	  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
	}
})
	  function handleTitleChange(e) {   #Hier zien we dus dat als er meerdere persons aanwezig zouden zijn in de dictionary dat die allemaal uitgepakt worden en per person object word ook weer het interne object uitgepakt.
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value
      }
    });
  }

#RENDER LOGICA

#Dit stuk JSX zouden we in een return van een Render functie tegenkomen. We lezen een boolean state uit om te bepalen welke html gerendered word
{this.state.change ? (
<h1>Welcome to Let’s React</h1>
) : (
<h1>Learn about the concepts of Reactjs</h1>
)}


#HOW TO USE GIT AND GITHUB
#https://github.com/settings/keys make an ssh connection with github
	#For this you want to create the ssh private and public key
	#/home/user_name/.ssh/id_rsa standaard plek waar private key leeft. .pub extension is de public. 
	#LINUX(git bash) ssh-keygen -t rsa  //  ssh-keygen -b 2048 -t rsa   (2de command mocht meer bytes nodig zijn)
	#WINDOWS blijkbaar met applicaties zoals PuTTY?? 
#Install git and Github. Don't use a gui for git but something like git bash command line
#git init    Als we in de directory zijn moeten we in de command line git init initeel doen om de directory in een git handelbare repository om te zetten
	#eenmalige actie binnen een directory (ziet volgens mij dan ook een file in de map komen voor de git commands ofzo)
#git add .    punt is een wildcard van add all files die veranderd zijn. Kunnen hier specifieker doorgeven. Zet files klaar voor te gaan uploaden naar github.
#git commit -m 'commit message here'     zet de files die added zijn klaar voor commit, nu zijn ze echt staged voor wanneer we pushen
#git status     kunnen we tussendoor doen om de lijst van added of staged to commit files te bekijken
#git push      om de files naar github te sturen

#git clone url (git@github.com:GithubSucksA/myron.git)    om een repo naar local te clonen. Zo kan je bijvoorbeeld de main branch naar je eigen halen.

--->dit zijn eenmalige handelingen die we moeten doen bij het aanmaken, veranderen, available maken van branches
#Wanneer we aan een project werken willen we met die repository in github connecten vanuit de command line
#initieel moeten we hiervoor !!   git remote add origin "url van repository"   doen zodat we connected zijn naar de repository
#git branch naambranch     dit call je nu om je eigen branch aan te maken
#git checkout naambranch     om naar een andere branch te gaan
#git push --set-upstream origin naambranch     om de branch toegankelijk te maken voor upstream
!!Meer onderzoek nodig naar master branch beveiliging

#STATES VS PROBS
#state handled een eigen component zijn waardes VS probs zijn de waarde die vanuit de parent worden doorgegeven
#we kunnen wel vanuit een parent een state doorgeven als een prop naar kinderen. Zo kunnen we ook over meerdere kinderen dezelfde state maintainen die leeft in de parent.
